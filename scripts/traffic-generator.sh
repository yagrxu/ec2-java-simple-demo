#!/bin/bash

# Traffic Generator for EC2 Java Simple Demo
# This script sends periodic requests to the application to generate traces and logs

# Configuration
APP_URL=${1:-"http://localhost:3030"}  # Default to localhost if no URL provided
INTERVAL=${2:-10}                       # Seconds between requests, default 10
MAX_RUNS=${3:-0}                        # Maximum number of runs (0 = infinite)
LOG_FILE="traffic-generator.log"        # Log file for the traffic generator

# Endpoints to test
ENDPOINTS=(
  "/api/products"
  "/api/products/health"
  "/api/products/in-stock"
  "/api/products/search?name=a"
  "/api/products/price-range?min=0&max=1000"
)

# Product IDs to test (will be populated dynamically)
PRODUCT_IDS=()

# Initialize log file
echo "$(date) - Traffic Generator Started" > $LOG_FILE
echo "Target Application: $APP_URL" >> $LOG_FILE
echo "Request Interval: $INTERVAL seconds" >> $LOG_FILE
echo "----------------------------------------" >> $LOG_FILE

# Function to make a request and log the result
make_request() {
  local endpoint=$1
  local method=${2:-"GET"}
  local data=${3:-""}
  local content_type=${4:-"application/json"}
  
  echo "$(date) - Making $method request to $endpoint"
  
  start_time=$(date +%s.%N)
  
  if [ "$method" == "GET" ]; then
    response=$(curl -s -w "\n%{http_code}" -X $method "$APP_URL$endpoint")
  else
    response=$(curl -s -w "\n%{http_code}" -X $method -H "Content-Type: $content_type" -d "$data" "$APP_URL$endpoint")
  fi
  
  end_time=$(date +%s.%N)
  duration=$(echo "$end_time - $start_time" | bc)
  
  # Extract status code from response
  status_code=$(echo "$response" | tail -n1)
  response_body=$(echo "$response" | sed '$d')
  
  # Log the result
  echo "$(date) - $method $endpoint - Status: $status_code, Time: ${duration}s" >> $LOG_FILE
  
  # Return the response body
  echo "$response_body"
}

# Function to get product IDs
update_product_ids() {
  echo "Fetching product IDs..."
  products_json=$(make_request "/api/products")
  
  # Check if we got a valid JSON response
  if [[ $products_json == *"id"* ]]; then
    # Extract product IDs using grep and sed
    # This is a simple extraction and might not work for all JSON structures
    PRODUCT_IDS=($(echo "$products_json" | grep -o '"id":[0-9]*' | grep -o '[0-9]*'))
    echo "Found ${#PRODUCT_IDS[@]} products: ${PRODUCT_IDS[@]}"
  else
    echo "Failed to fetch product IDs or no products found"
  fi
}

# Function to create a random product
create_random_product() {
  local name="Product-$(date +%s)"
  local price=$(echo "scale=2; $RANDOM / 100" | bc)
  local stock=$((RANDOM % 100))
  
  local data="{\"name\":\"$name\",\"description\":\"Generated by traffic script\",\"price\":$price,\"stockQuantity\":$stock}"
  
  echo "Creating new product: $data"
  make_request "/api/products" "POST" "$data"
}

# Function to update a random product
update_random_product() {
  if [ ${#PRODUCT_IDS[@]} -eq 0 ]; then
    echo "No products to update"
    return
  fi
  
  # Select a random product ID
  local index=$((RANDOM % ${#PRODUCT_IDS[@]}))
  local id=${PRODUCT_IDS[$index]}
  
  local name="Updated-$(date +%s)"
  local price=$(echo "scale=2; $RANDOM / 100" | bc)
  local stock=$((RANDOM % 100))
  
  local data="{\"name\":\"$name\",\"description\":\"Updated by traffic script\",\"price\":$price,\"stockQuantity\":$stock}"
  
  echo "Updating product $id: $data"
  make_request "/api/products/$id" "PUT" "$data"
}

# Function to delete a random product
delete_random_product() {
  if [ ${#PRODUCT_IDS[@]} -eq 0 ]; then
    echo "No products to delete"
    return
  fi
  
  # Select a random product ID
  local index=$((RANDOM % ${#PRODUCT_IDS[@]}))
  local id=${PRODUCT_IDS[$index]}
  
  echo "Deleting product $id"
  make_request "/api/products/$id" "DELETE"
  
  # Remove the ID from our array
  unset PRODUCT_IDS[$index]
  PRODUCT_IDS=("${PRODUCT_IDS[@]}")
}

# Main loop
run_count=0
while true; do
  # Check if we've reached the maximum number of runs
  if [ $MAX_RUNS -gt 0 ] && [ $run_count -ge $MAX_RUNS ]; then
    echo "Reached maximum number of runs ($MAX_RUNS). Exiting."
    break
  fi
  
  # Update product IDs periodically
  if [ $((run_count % 5)) -eq 0 ]; then
    update_product_ids
  fi
  
  # Select a random endpoint
  endpoint=${ENDPOINTS[$RANDOM % ${#ENDPOINTS[@]}]}
  
  # Make the request
  echo "Run #$run_count: Requesting $endpoint"
  make_request "$endpoint"
  
  # Occasionally perform write operations
  if [ $((RANDOM % 10)) -eq 0 ]; then
    action=$((RANDOM % 3))
    case $action in
      0) create_random_product ;;
      1) update_random_product ;;
      2) delete_random_product ;;
    esac
  fi
  
  # Increment run count
  run_count=$((run_count + 1))
  
  # Sleep for the specified interval
  sleep $INTERVAL
done

echo "$(date) - Traffic Generator Stopped" >> $LOG_FILE
